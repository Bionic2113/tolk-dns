"Asm.fif" include
// automatically generated from nft-collection.tolk, dns-utils.tolk, messages.tolk, storage.tolk
PROGRAM{
  DECLPROC minPrice()
  0 DECLMETHOD onInternalMessage()
  102491 DECLMETHOD get_collection_data()
  92067 DECLMETHOD get_nft_address_by_index()
  68445 DECLMETHOD get_nft_content()
  123660 DECLMETHOD dnsresolve()
  // 7 functions inlined in-place:
  // - checkDomainString (1 call)
  // - topDomainBits (1 call)
  // - minPriceConfig (1 call)
  // - DomainSlice.unpackFromSlice (0 calls)
  // - NftCollectionStorage.load (3 calls)
  // - calcDeployedNftItem (2 calls)
  // - deployNftItem (1 call)
  // dns-utils.tolk:64
  minPrice() PROC:<{          	//  domainBitsLength nowTime
    // 65: var minPrice = minPriceConfig(domainBitsLength / 8)
    SWAP                    	//  nowTime domainBitsLength
    3 RSHIFT#               	//  nowTime '5
    // 53: 4 => (1000, 100)
    DUP                     	//  nowTime '5 '5
    4 EQINT                 	//  nowTime '5 '11
    IF:<{                   	//  nowTime '5
      DROP                  	//  nowTime
      1000 PUSHINT          	//  nowTime '12=1000
      100 PUSHINT           	//  nowTime '8=1000 '9=100
    }>ELSE<{                	//  nowTime '5
      // 54: 5 => (500, 50)
      DUP                   	//  nowTime '5 '5
      5 EQINT               	//  nowTime '5 '15
      IF:<{                 	//  nowTime '5
        DROP                	//  nowTime
        500 PUSHINT         	//  nowTime '16=500
        50 PUSHINT          	//  nowTime '8=500 '9=50
      }>ELSE<{              	//  nowTime '5
        // 55: 6 => (400, 40)
        DUP                 	//  nowTime '5 '5
        6 EQINT             	//  nowTime '5 '19
        IF:<{               	//  nowTime '5
          DROP              	//  nowTime
          400 PUSHINT       	//  nowTime '20=400
          40 PUSHINT        	//  nowTime '8=400 '9=40
        }>ELSE<{            	//  nowTime '5
          // 56: 7 => (300, 30)
          DUP               	//  nowTime '5 '5
          7 EQINT           	//  nowTime '5 '23
          IF:<{             	//  nowTime '5
            DROP            	//  nowTime
            300 PUSHINT     	//  nowTime '24=300
            30 PUSHINT      	//  nowTime '8=300 '9=30
          }>ELSE<{          	//  nowTime '5
            // 57: 8 => (200, 20)
            DUP             	//  nowTime '5 '5
            8 EQINT         	//  nowTime '5 '27
            IF:<{           	//  nowTime '5
              DROP          	//  nowTime
              200 PUSHINT   	//  nowTime '28=200
              20 PUSHINT    	//  nowTime '8=200 '9=20
            }>ELSE<{        	//  nowTime '5
              // 58: 9 => (100, 10)
              DUP           	//  nowTime '5 '5
              9 EQINT       	//  nowTime '5 '31
              IF:<{         	//  nowTime '5
                DROP        	//  nowTime
                100 PUSHINT 	//  nowTime '32=100
                10 PUSHINT  	//  nowTime '8=100 '9=10
              }>ELSE<{      	//  nowTime '5
                // 59: 10 => (50, 5)
                10 EQINT    	//  nowTime '35
                IF:<{       	//  nowTime
                  50 PUSHINT	//  nowTime '36=50
                  5 PUSHINT 	//  nowTime '8=50 '9=5
                }>ELSE<{    	//  nowTime
                  // 60: else => (10, 1)
                  10 PUSHINT	//  nowTime '38=10
                  1 PUSHINT 	//  nowTime '8=10 '9=1
                }>
              }>
            }>
          }>
        }>
      }>
    }>                      	//  nowTime minPrice.0 minPrice.1
    // 67: minPrice.0 *= ONE_TON
    SWAP
    1000000000 PUSHINT      	//  nowTime minPrice.1 minPrice.0 '40=1000000000
    MUL                     	//  nowTime minPrice.1 minPrice.0
    // 68: minPrice.1 *= ONE_TON
    SWAP
    1000000000 PUSHINT      	//  nowTime minPrice.0 minPrice.1 '42=1000000000
    MUL                     	//  nowTime minPrice.0 minPrice.1
    // 70: val seconds = nowTime - AUCTION_START_TIME
    s0 s2 XCHG
    1659171600 PUSHINT      	//  minPrice.1 minPrice.0 nowTime '45=1659171600
    SUB                     	//  minPrice.1 minPrice.0 seconds
    // 71: val months = seconds / ONE_MONTH
    2592000 PUSHINT         	//  minPrice.1 minPrice.0 seconds '48=2592000
    DIV                     	//  minPrice.1 minPrice.0 months
    // 72: if (months > 21)
    DUP                     	//  minPrice.1 minPrice.0 months months
    21 GTINT                	//  minPrice.1 minPrice.0 months '51
    IFJMP:<{                	//  minPrice.1 minPrice.0 months
      2DROP                 	//  minPrice.1
    }>                      	//  minPrice.1 minPrice.0 months
    1 2 BLKDROP2            	//  minPrice.0 months
    // 76: repeat (months)
    REPEAT:<{               	//  minPrice.0
      // 77: minPrice.0 = minPrice.0 * 90 / 100
      90 MULCONST           	//  '53
      100 PUSHINT           	//  '53 '54=100
      DIV                   	//  minPrice.0
    }>
  }>
  // nft-collection.tolk:22
  onInternalMessage() PROC:<{ 	//  in.body
    // 22: fun onInternalMessage(in: InMessage)
    INMSG_BOUNCED           	//  in.body '1
    0 THROWIF               	//  in.body
    // 23: assert (!in.body.isEmpty()) throw 0xFFFF
    16 PUSHPOW2DEC          	//  in.body '4=65535
    OVER                    	//  in.body '4=65535 in.body
    SEMPTY                  	//  in.body '4=65535 '5
    NOT                     	//  in.body '4=65535 '6
    THROWANYIFNOT           	//  lazyS
    // 26: match (msg)
    x{370fec51} SDBEGINSQ   	//  lazyS '13
    IFJMP:<{                	//  lazyS
      // 28: return
      DROP                  	// 
    }>                      	//  lazyS
    // 26: match (msg)
    x{00000000} SDBEGINSQ   	//  lazyS '13
    IFJMP:<{                	//  lazyS
      // 32: val now_time = blockchain.now()
      NOW                   	//  lazyS now_time
      // 33: assert (now_time > AUCTION_START_TIME) throw 199
      DUP
      1659171600 PUSHINT    	//  lazyS now_time now_time '21=1659171600
      GREATER               	//  lazyS now_time '22
      199 THROWIFNOT        	//  comment now_time
      // 13: var domain: builder = beginCell()
      NEWC                  	//  comment now_time domain
      // 15: do
      // ...25: while (!needBreak)
      UNTIL:<{
        // 16: domain.storeSlice(comment.loadBits(comment.remainingBitsCount()))
        s2 PUSH             	//  comment now_time domain comment
        SBITS               	//  comment now_time domain '32
        s1 s3 XCHG          	//  domain now_time comment '32
        LDSLICEX            	//  domain now_time '35 comment
        s0 s3 XCHG          	//  comment now_time '35 domain
        STSLICE             	//  comment now_time domain
        // 18: val refsLen = comment.remainingRefsCount()
        s2 PUSH             	//  comment now_time domain comment
        SREFS               	//  comment now_time domain refsLen
        // 19: needBreak = refsLen == 0
        DUP                 	//  comment now_time domain refsLen refsLen
        0 EQINT             	//  comment now_time domain refsLen needBreak
        // 21: if (!needBreak)
        DUP                 	//  comment now_time domain refsLen needBreak needBreak
        IFNOT:<{            	//  comment now_time domain refsLen needBreak
          // 22: assert (refsLen == 1) throw 202
          SWAP              	//  comment now_time domain needBreak refsLen
          1 EQINT           	//  comment now_time domain needBreak '43
          202 THROWIFNOT    	//  comment now_time domain needBreak
          // 23: comment = comment.loadRef().beginParse()
          s0 s3 XCHG        	//  needBreak now_time domain comment
          PLDREF            	//  needBreak now_time domain '46
          CTOS              	//  needBreak now_time domain comment
          // 21: if (!needBreak)
          s0 s3 XCHG        	//  comment now_time domain needBreak
        }>ELSE<{
          NIP               	//  comment now_time domain needBreak
        }>                  	//  comment now_time domain '49
      }>                    	//  comment now_time domain
      1 2 BLKDROP2          	//  now_time domain
      // 27: return domain.toSlice()
      BTOS                  	//  now_time msg.USlot1
      // 37: val len: int = msg.domain.remainingBitsCount()
      DUP                   	//  now_time msg.USlot1 msg.USlot1
      SBITS                 	//  now_time msg.USlot1 len
      // 39: assert (len > 3 * 8) throw 200; // minimum 4 characters
      DUP                   	//  now_time msg.USlot1 len len
      24 GTINT              	//  now_time msg.USlot1 len '57
      200 THROWIFNOT        	//  now_time msg.USlot1 len
      // 40: assert (len <= 126 * 8) throw 201; // maximum 126 characters
      DUP
      1008 PUSHINT          	//  now_time msg.USlot1 len len '61
      LEQ                   	//  now_time msg.USlot1 len '62
      201 THROWIFNOT        	//  now_time msg.USlot1 len
      // 41: assert (mod(len, 8) == 0) throw 202
      DUP
      8 PUSHINT             	//  now_time msg.USlot1 len len '64=8
      MOD                   	//  now_time msg.USlot1 len '65
      202 THROWIF           	//  now_time msg.USlot1 len
      // 42: assert (checkDomainString(msg.domain)) throw 203
      OVER                  	//  now_time msg.USlot1 len domain
      // 14: var i: int = 0
      0 PUSHINT             	//  now_time msg.USlot1 len domain i=0
      // 15: var len: int = domain.remainingBitsCount()
      OVER                  	//  now_time msg.USlot1 len domain i=0 domain
      SBITS                 	//  now_time msg.USlot1 len domain i=0 len
      // 17: do
      // ...32: while (!needBreak)
      UNTIL:<{
        2DUP                	//  now_time msg.USlot1 len domain i len i len
        // 18: needBreak = i == len
        EQUAL               	//  now_time msg.USlot1 len domain i len needBreak
        // 19: if (!needBreak)
        DUP                 	//  now_time msg.USlot1 len domain i len needBreak needBreak
        IFNOT:<{            	//  now_time msg.USlot1 len domain i len needBreak
          // 20: var char: int = domain.loadUint(8)
          DROP              	//  now_time msg.USlot1 len domain i len
          s0 s2 XCHG        	//  now_time msg.USlot1 len len i domain
          8 LDU             	//  now_time msg.USlot1 len len i char domain
          // 22: var isHyphen: bool = (char == 45)
          OVER              	//  now_time msg.USlot1 len len i char domain char
          45 EQINT          	//  now_time msg.USlot1 len len i char domain isHyphen
          // 23: var validChar: bool = (isHyphen & (i > 0) & (i < len - 8)) |
          s3 PUSH           	//  now_time msg.USlot1 len len i char domain isHyphen i
          0 GTINT           	//  now_time msg.USlot1 len len i char domain isHyphen '88
          AND               	//  now_time msg.USlot1 len len i char domain '89
          s4 PUSH           	//  now_time msg.USlot1 len len i char domain '89 len
          -8 ADDCONST       	//  now_time msg.USlot1 len len i char domain '89 '91
          s4 PUSH           	//  now_time msg.USlot1 len len i char domain '89 '91 i
          GREATER           	//  now_time msg.USlot1 len len i char domain '89 '92
          AND               	//  now_time msg.USlot1 len len i char domain '93
          // 24: ((char >= 48) & (char <= 57)) |
          s2 PUSH           	//  now_time msg.USlot1 len len i char domain '93 char
          47 GTINT          	//  now_time msg.USlot1 len len i char domain '93 '95
          s3 PUSH           	//  now_time msg.USlot1 len len i char domain '93 '95 char
          58 LESSINT        	//  now_time msg.USlot1 len len i char domain '93 '95 '97
          AND               	//  now_time msg.USlot1 len len i char domain '93 '98
          // 23: var validChar: bool = (isHyphen & (i > 0) & (i < len - 8)) |
          // ...24: ((char >= 48) & (char <= 57))
          OR                	//  now_time msg.USlot1 len len i char domain '99
          // 25: ((char >= 97) & (char <= 122)); // '-' or 0-9 or a-z
          s2 PUSH           	//  now_time msg.USlot1 len len i char domain '99 char
          96 GTINT          	//  now_time msg.USlot1 len len i char domain '99 '101
          s0 s3 XCHG        	//  now_time msg.USlot1 len len i '101 domain '99 char
          123 LESSINT       	//  now_time msg.USlot1 len len i '101 domain '99 '103
          s1 s3 XCHG        	//  now_time msg.USlot1 len len i '99 domain '101 '103
          AND               	//  now_time msg.USlot1 len len i '99 domain '104
          // 23: var validChar: bool = (isHyphen & (i > 0) & (i < len - 8)) |
          // ...25: ((char >= 97) & (char <= 122))
          s1 s2 XCHG        	//  now_time msg.USlot1 len len i domain '99 '104
          OR                	//  now_time msg.USlot1 len len i domain validChar
          // 27: needBreak = !validChar
          NOT               	//  now_time msg.USlot1 len len i domain needBreak
          // 28: if (!needBreak)
          DUP               	//  now_time msg.USlot1 len len i domain needBreak needBreak
          IFNOT:<{          	//  now_time msg.USlot1 len len i domain needBreak
            // 29: i += 8
            s0 s2 XCHG      	//  now_time msg.USlot1 len len needBreak domain i
            8 ADDCONST      	//  now_time msg.USlot1 len len needBreak domain i
            // 28: if (!needBreak)
            s0 s2 XCHG      	//  now_time msg.USlot1 len len i domain needBreak
          }>                	//  now_time msg.USlot1 len len i domain needBreak
          // 19: if (!needBreak)
          s1 s3 XCHG        	//  now_time msg.USlot1 len domain i len needBreak
        }>                  	//  now_time msg.USlot1 len domain i len '110
      }>                    	//  now_time msg.USlot1 len domain i len
      // 33: return i == len
      s2 POP                	//  now_time msg.USlot1 len len i
      EQUAL                 	//  now_time msg.USlot1 len '70
      // 42: assert (checkDomainString(msg.domain)) throw 203
      203 THROWIFNOT        	//  now_time msg.USlot1 len
      // 43: assert (in.valueCoins >= minPrice(len, now_time)) throw 204
      INMSG_VALUE           	//  now_time msg.USlot1 len '113
      s0 s3 XCHG            	//  '113 msg.USlot1 len now_time
      minPrice() CALLDICT   	//  '113 msg.USlot1 '115
      s1 s2 XCHG            	//  msg.USlot1 '113 '115
      GEQ                   	//  msg.USlot1 '116
      204 THROWIFNOT        	//  msg.USlot1
      // 44: val itemIndex: int = msg.domain.hash()
      DUP                   	//  msg.USlot1 msg.USlot1
      HASHSU                	//  msg.USlot1 itemIndex
      // 46: val config: cell? = blockchain.configParam(DNS_CONFIG_ID)
      80 PUSHINT            	//  msg.USlot1 itemIndex '120=80
      CONFIGOPTPARAM        	//  msg.USlot1 itemIndex config
      // 47: if (config != null)
      DUP                   	//  msg.USlot1 itemIndex config config
      ISNULL                	//  msg.USlot1 itemIndex config '122
      IFNOT:<{              	//  msg.USlot1 itemIndex config
        // 48: val element = config.beginParse().loadDict().uDictGet(256, itemIndex)
        CTOS                	//  msg.USlot1 itemIndex '125
        PLDDICT             	//  msg.USlot1 itemIndex '128
        s1 s(-1) PUXC
        8 PUSHPOW2          	//  msg.USlot1 itemIndex itemIndex '128 '129=256
        DICTUGET
        NULLSWAPIFNOT       	//  msg.USlot1 itemIndex '130 '131
        NIP                 	//  msg.USlot1 itemIndex element.1
        // 49: assert (!element.1) throw 205
        205 THROWIF         	//  msg.USlot1 itemIndex
      }>ELSE<{
        // 47: if (config != null)
        DROP                	//  msg.USlot1 itemIndex
      }>
      // 59: return NftCollectionStorage.fromCell(contract.getData())
      c4 PUSH               	//  msg.USlot1 itemIndex '137
      // 52: val nftStorage = lazy NftCollectionStorage.load()
      CTOS                  	//  msg.USlot1 itemIndex lazyS
      // 54: sender: in.senderAddress
      INMSG_SRC             	//  msg.USlot1 itemIndex lazyS '143
      // 55: domain: Domain { domain: msg.domain }.toCell()
      s0 s3 XCHG
      NEWC                  	//  '143 itemIndex lazyS msg.USlot1 b
      STSLICE               	//  '143 itemIndex lazyS b
      ENDC                  	//  nftContent.sender itemIndex lazyS nftContent.domain
      // 58: deployNftItem(itemIndex, nftStorage.nftItemCode, nftContent)
      SWAP                  	//  nftContent.sender itemIndex nftContent.domain lazyS
      LDREF                 	//  nftContent.sender itemIndex nftContent.domain '148 lazyS
      NIP                   	//  nftContent.sender itemIndex nftContent.domain lazyS
      PLDREF                	//  nftContent.sender itemIndex nftContent.domain nftStorage.nftItemCode
      // 13: dest: calcDeployedNftItem(itemIndex, contract.getAddress(), nftItemCode)
      MYADDR                	//  nftContent.sender emptyNftItemStorage.itemIndex nftContent.domain nftStorage.nftItemCode emptyNftItemStorage.collectionAddress
      // 69: return { stateInit: { code: nftItemCode, data: emptyNftItemStorage.toCell() } }
      s0 s3 XCHG
      NEWC                  	//  nftContent.sender emptyNftItemStorage.collectionAddress nftContent.domain nftStorage.nftItemCode emptyNftItemStorage.itemIndex b
      256 STU               	//  nftContent.sender emptyNftItemStorage.collectionAddress nftContent.domain nftStorage.nftItemCode b
      s1 s3 XCHG            	//  nftContent.sender nftStorage.nftItemCode nftContent.domain emptyNftItemStorage.collectionAddress b
      STSTDADDR             	//  nftContent.sender nftStorage.nftItemCode nftContent.domain b
      ENDC                  	//  '189 'USlot2 '190 'USlot3
      // 11: val deployMsg = createMessage(
      NEWC                  	//  '189 'USlot2 '190 'USlot3 b
      b{01100010000000000} STSLICECONST	//  '189 'USlot2 '190 'USlot3 b
      s1 s3 PUSH2           	//  '189 'USlot2 '190 'USlot3 b 'USlot3 'USlot2
      NEWC
      b{00110} STSLICECONST
      STREF
      STREF
      HASHBU                	//  '189 'USlot2 '190 'USlot3 b '211
      256 STUR              	//  '189 'USlot2 '190 'USlot3 b
      140 PUSHINT
      117 STUR              	//  '189 'USlot2 '190 'USlot3 b
      s1 s3 XCHG            	//  '189 'USlot3 '190 'USlot2 b
      STREF                 	//  '189 'USlot3 '190 b
      s1 s2 XCHG            	//  '189 '190 'USlot3 b
      STREF                 	//  '189 '190 b
      s1 s2 XCHG            	//  '190 '189 b
      STSTDADDR             	//  '190 b
      STREF                 	//  b
      ENDC                  	//  deployMsg
      // 17: deployMsg.send(SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE)
      64 PUSHINT            	//  deployMsg '255=64
      SENDRAWMSG            	// 
    }>                      	//  lazyS
    // 62: throw 0xffff
    16 PUSHPOW2DEC
    THROWANY
  }>
  // nft-collection.tolk:73
  get_collection_data() PROC:<{	// 
    // 59: return NftCollectionStorage.fromCell(contract.getData())
    c4 PUSH                 	//  '3
    // 74: val storage = lazy NftCollectionStorage.load()
    CTOS                    	//  lazyS
    // 76: return
    PLDREF                  	//  storage.content
    // 77: nextItemIndex: -1
    -1 PUSHINT              	//  storage.content '8=-1
    // 76: return
    SWAP
    // 79: adminAddress: null
    PUSHNULL                	//  '8=-1 storage.content '9
  }>
  // nft-collection.tolk:83
  get_nft_address_by_index() PROC:<{	//  itemIndex
    // 59: return NftCollectionStorage.fromCell(contract.getData())
    c4 PUSH                 	//  itemIndex '4
    // 84: val storage = lazy NftCollectionStorage.load()
    CTOS                    	//  itemIndex lazyS
    // 85: val nftDeployed = calcDeployedNftItem(itemIndex, contract.getAddress(), storage.nftItemCode)
    LDREF                   	//  itemIndex '8 lazyS
    NIP                     	//  itemIndex lazyS
    PLDREF                  	//  itemIndex storage.nftItemCode
    MYADDR                  	//  emptyNftItemStorage.itemIndex storage.nftItemCode emptyNftItemStorage.collectionAddress
    // 69: return { stateInit: { code: nftItemCode, data: emptyNftItemStorage.toCell() } }
    s0 s2 XCHG
    NEWC                    	//  emptyNftItemStorage.collectionAddress storage.nftItemCode emptyNftItemStorage.itemIndex b
    256 STU                 	//  emptyNftItemStorage.collectionAddress storage.nftItemCode b
    s1 s2 XCHG              	//  storage.nftItemCode emptyNftItemStorage.collectionAddress b
    STSTDADDR               	//  storage.nftItemCode b
    ENDC                    	//  nftDeployed.stateInit.USlot1 nftDeployed.stateInit.USlot2
    // 87: return nftDeployed.calculateAddress()
    SWAP                    	//  nftDeployed.stateInit.USlot2 nftDeployed.stateInit.USlot1
    NEWC
    b{00110} STSLICECONST
    STREF
    STREF
    HASHBU                  	//  '37
    NEWC                    	//  '37 '36
    b{10000000000} STSLICECONST	//  '37 '36
    256 STU                 	//  '36
    BTOS                    	//  '36
  }>
  // nft-collection.tolk:90
  get_nft_content() PROC:<{   	//  itemIndex individualNftContent
    // 91: return individualNftContent
    NIP                     	//  individualNftContent
  }>
  // nft-collection.tolk:94
  dnsresolve() PROC:<{        	//  subdomain category
    // 95: val subdomainLen = subdomain.remainingBitsCount()
    DROP                    	//  subdomain
    DUP                     	//  subdomain subdomain
    SBITS                   	//  subdomain subdomainLen
    // 97: assert (mod(subdomainLen, 8) == 0) throw 70
    DUP
    8 PUSHINT               	//  subdomain subdomainLen subdomainLen '5=8
    MOD                     	//  subdomain subdomainLen '6
    70 THROWIF              	//  subdomain subdomainLen
    // 99: val startsWithZeroByte: bool = subdomain.preloadInt(8) == 0
    OVER                    	//  subdomain subdomainLen subdomain
    8 PLDI                  	//  subdomain subdomainLen '11
    0 EQINT                 	//  subdomain subdomainLen startsWithZeroByte
    // 101: if (startsWithZeroByte && subdomainLen == 8)
    DUP                     	//  subdomain subdomainLen startsWithZeroByte startsWithZeroByte
    IF:<{                   	//  subdomain subdomainLen startsWithZeroByte
      SWAP                  	//  subdomain startsWithZeroByte subdomainLen
      8 EQINT               	//  subdomain startsWithZeroByte '16
      0 NEQINT              	//  subdomain startsWithZeroByte '14
    }>ELSE<{                	//  subdomain subdomainLen startsWithZeroByte
      NIP                   	//  subdomain startsWithZeroByte
      0 PUSHINT             	//  subdomain startsWithZeroByte '14=0
    }>
    IFJMP:<{                	//  subdomain startsWithZeroByte
      2DROP                 	// 
      // 102: return (8, null)
      8 PUSHINT             	//  '20=8
      PUSHNULL              	//  '20=8 '21
    }>                      	//  subdomain startsWithZeroByte
    // 105: if (startsWithZeroByte)
    DUP                     	//  subdomain startsWithZeroByte startsWithZeroByte
    IF:<{                   	//  subdomain startsWithZeroByte
      // 106: subdomain.loadUint(8)
      SWAP                  	//  startsWithZeroByte subdomain
      8 LDU                 	//  startsWithZeroByte '24 '23
      NIP                   	//  startsWithZeroByte subdomain
      // 105: if (startsWithZeroByte)
      SWAP                  	//  subdomain startsWithZeroByte
    }>                      	//  subdomain startsWithZeroByte
    // 109: val topSubdomainBits: int = topDomainBits(subdomain)
    OVER                    	//  subdomain startsWithZeroByte domain
    // 37: var i: int = 0
    0 PUSHINT               	//  subdomain startsWithZeroByte domain i=0
    // 40: do
    // ...45: while (!needBreak)
    UNTIL:<{
      // 41: needBreak = domain.loadUint(8) == 0
      SWAP                  	//  subdomain startsWithZeroByte i domain
      8 LDU                 	//  subdomain startsWithZeroByte i '36 domain
      SWAP                  	//  subdomain startsWithZeroByte i domain '36
      0 EQINT               	//  subdomain startsWithZeroByte i domain needBreak
      // 42: if (!needBreak)
      DUP                   	//  subdomain startsWithZeroByte i domain needBreak needBreak
      IFNOT:<{              	//  subdomain startsWithZeroByte i domain needBreak
        // 43: i += 8
        s0 s2 XCHG          	//  subdomain startsWithZeroByte needBreak domain i
        8 ADDCONST          	//  subdomain startsWithZeroByte needBreak domain i
        // 42: if (!needBreak)
        s0 s2 XCHG          	//  subdomain startsWithZeroByte i domain needBreak
      }>                    	//  subdomain startsWithZeroByte i domain '42
      // 40: do
      // ...45: while (!needBreak)
      s1 s2 XCHG            	//  subdomain startsWithZeroByte domain i '42
    }>                      	//  subdomain startsWithZeroByte domain i
    // 47: assert (i != 0) throw 201
    NIP                     	//  subdomain startsWithZeroByte i
    DUP                     	//  subdomain startsWithZeroByte i i
    201 THROWIFNOT          	//  subdomain startsWithZeroByte topSubdomainBits
    s2 s2 XCPU              	//  topSubdomainBits startsWithZeroByte subdomain topSubdomainBits
    // 110: val item_index = subdomain.loadBits(topSubdomainBits).hash()
    PLDSLICEX               	//  topSubdomainBits startsWithZeroByte '49
    HASHSU                  	//  topSubdomainBits startsWithZeroByte item_index
    // 113: topSubdomainBits + (startsWithZeroByte ? 8 : 0)
    SWAP
    8 PUSHINT
    0 PUSHINT               	//  topSubdomainBits item_index startsWithZeroByte '52=8 '53=0
    CONDSEL                 	//  topSubdomainBits item_index '51
    s1 s2 XCHG              	//  item_index topSubdomainBits '51
    ADD                     	//  item_index '54
    // 114: ResolveResponse { next: get_nft_address_by_index(item_index) }.toCell()
    SWAP                    	//  '54 item_index
    get_nft_address_by_index() CALLDICT	//  '54 '55
    NEWC                    	//  '54 '55 b
    x{ba93} STSLICECONST    	//  '54 '55 b
    STSTDADDR               	//  '54 b
    ENDC                    	//  '54 '60
  }>
}END>c
